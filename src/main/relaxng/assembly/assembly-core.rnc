namespace ctrl = "http://nwalsh.com/xmlns/schema-control/"
namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"
namespace rng  = "http://relaxng.org/ns/structure/1.0"
namespace s = "http://purl.oclc.org/dsdl/schematron"
namespace db = "http://docbook.org/ns/docbook"
default namespace = "http://docbook.org/ns/docbook"

db.grammar.attribute =
   [
      db:refpurpose [ "Identifies the markup grammar of a resource" ]
   ]
   attribute grammar { text }

# ======================================================================

[
   db:refname [ "assembly" ]
   db:refmiscinfo [ class = "manual" "assembly" ]
   db:refpurpose [ "Defines the hierarchy and relationships for a collection of resources" ]
]
div {

   db.assembly.role.attribute = attribute role { text }

   db.assembly.attlist =
      db.assembly.role.attribute?
    & db.common.attributes

   db.assembly.info = db._info

   db.assembly =
      element assembly {
         db.assembly.attlist,
         db.assembly.info,
         db.resources+,
         db.structure*,
         db.relationships*,
         db.transforms?
      }
}

# ======================================================================

[
   db:refname [ "resources" ]
   db:refmiscinfo [ class = "manual" "assembly" ]
   db:refpurpose [ "Contains one or more resource objects that are managed by the assembly" ]
]
div {

   db.resources.role.attribute = attribute role { text }

   db.resources.grammar.attribute = db.grammar.attribute

   db.resources.attlist =
      db.resources.role.attribute?
    & db.resources.grammar.attribute?
    & db.common.attributes

   db.resources.info = db._info.title.forbidden

   db.resources =
      element resources {
         db.resources.attlist,
         db.resources.info?,
         (db.description*, db.resource+)
      }
}

# ======================================================================

[
   db:refname [ "resource" ]
   db:refmiscinfo [ class = "manual" "assembly" ]
   db:refpurpose [ "Identifies an object managed within the assembly" ]
]
div {

   db.resource.role.attribute = attribute role { text }

   db.resource.href.attribute =
      [
         db:refpurpose [ "Indentifies the location of the data by URI" ]
      ]
      attribute href { xsd:anyURI }

   db.resource.grammar.attribute = db.grammar.attribute
   
   db.resource.transform.attribute =
   [
      db:refpurpose [ "Identifies the markup grammar of a resource" ]
   ]
   attribute transform { xsd:NMTOKEN }


   db.resource.attlist =
      db.resource.role.attribute?
    & (db.resource.transform.attribute | db.resource.grammar.attribute)?
    & db.common.attributes

   db.resource =
      element resource {
         db.resource.attlist,
         db.resource.href.attribute,
         db.description*
      }
}

# ======================================================================

[
   db:refname [ "structure" ]
   db:refmiscinfo [ class = "manual" "assembly" ]
   db:refpurpose [ "Describes the structure of a document" ]
]
div {

   db.structure.role.attribute = attribute role { text }

   db.structure.type.attribute =
      [
         db:refpurpose [ "Identifies the structure type of the structure" ]
      ]
      attribute type { xsd:NMTOKEN }

   db.structure.resourceref.attribute =
      [
         db:refpurpose [ "Indicates a single resource from which to construct this structure" ]
      ]
      attribute resourceref { xsd:IDREF }

   db.structure.defaultformat.attribute =
      [
         db:refpurpose [ "Identifies the default format of the structure" ]
      ]
      attribute defaultformat { xsd:NMTOKEN }

   db.structure.renderas.attribute =
      [
         db:refpurpose [ "Specifies the DocBook element to which this unit should be renamed" ]
      ]
      attribute renderas { xsd:QName }

   db.structure.attlist =
      db.structure.role.attribute?
    & db.structure.type.attribute?
    & db.structure.resourceref.attribute?
    & db.structure.renderas.attribute?
    & db.structure.defaultformat.attribute?
    & db.common.attributes

   db.structure.info = db.info?

   db.structure =
      [
         s:pattern [
            s:title [ "Specification of renderas" ]
            s:rule [
               context = "db:structure"
               s:assert [
                  test = "not(@renderas and db:output/@renderas)"
                  "The renderas attribute can be specified on either the structure or output, but not both."
               ]
            ]
         ]
      ]
      element structure {
         db.structure.attlist,
         (db.output* & db.filterin? & db.filterout? & db.structure.info),
         db.merge?,
         db.revhistory?,
         db.module+
      }
}

# ======================================================================

[
   db:refname [ "output" ]
   db:refmiscinfo [ class = "manual" "assembly" ]
   db:refpurpose [ "Specify an output format and/or file name and/or renderas" ]
]
div {

   db.output.role.attribute = attribute role { text }

   db.output.chunk.enumeration =
      ## This module will be in a chunk
      "true"
    | ## This module will not be in a chunk
      "false"
    | ## Chunking of this module depends on the overall chunking algorithm
      "auto"

   db.output.chunk.attribute =
      [
         a:defaultValue = "auto"
         db:refpurpose [ "Specifies chunking for this module" ]
      ]
      attribute chunk { db.module.chunk.enumeration }

   db.output.file.attribute =
      [
         db:refpurpose [ "Specifies the output file for this module or structure" ]
      ]
      attribute file { xsd:anyURI }

   db.output.renderas.attribute =
      [
         db:refpurpose [ "Specifies the DocBook element to which this unit should be renamed" ]
      ]
      attribute renderas { xsd:QName }

   db.output.transform.attribute =
      [
         db:refpurpose [ "Specifies the transformation that should be applied to this unit" ]
      ]
      attribute transform { xsd:NMTOKEN }

   db.output.suppress.attribute =
      [
         db:refpurpose [ "Indicates whether or not this unit should be suppressed" ]
      ]
      attribute suppress { xsd:boolean }

   db.output.attlist =
      db.output.role.attribute?
    & db.common.attributes
    & db.output.chunk.attribute?
    & db.output.file.attribute?
    & db.output.renderas.attribute?
    & db.output.transform.attribute?
    & db.output.suppress.attribute?

   db.output =
      element output {
         db.output.attlist,
         empty
      }
}

# ======================================================================

[
   db:refname [ "merge" ]
   db:refmiscinfo [ class = "manual" "assembly" ]
   db:refpurpose [ "A wrapper for information that a module overrides in the resource it includes" ]
]
div {

   db.merge.role.attribute = attribute role { text }

   db.merge.resourceref.attribute =
      [
         db:refpurpose [ "Indicates a single resource from which to read merged info" ]
      ]
      attribute resourceref { xsd:IDREF }

   db.merge.attlist =
      db.merge.role.attribute?
    & db.merge.resourceref.attribute?
    & db.common.attributes

   db.merge =
      element merge {
         db.merge.attlist,
         (db._title & db.info.elements*)
      }
}

# ======================================================================

[
   db:refname [ "module" ]
   db:refmiscinfo [ class = "manual" "assembly" ]
   db:refpurpose [ "A modular component within a structure" ]
]
div {

   db.module.role.attribute = attribute role { text }

   db.module.chunk.enumeration =
      ## This module will be in a chunk
      "true"
    | ## This module will not be in a chunk
      "false"
    | ## Chunking of this module depends on the overall chunking algorithm
      "auto"

   db.module.chunk.attribute =
      [
         a:defaultValue = "auto"
         db:refpurpose [ "Specifies chunking for this module" ]
      ]
      attribute chunk { db.module.chunk.enumeration }

   db.module.resourceref.attribute =
      [
         db:refpurpose [ "Identifies a single resource or structure within the assembly from which to construct this module" ]
      ]
      attribute resourceref { xsd:IDREF }

   db.module.omittitles.attribute =
      [
         db:refpurpose [ "Indicates if titles should be omitted when including a resource" ]
      ]
      attribute omittitles { xsd:boolean }?

   db.module.contentonly.attribute =
      [
         db:refpurpose [ "Indicates if the root element should be omitted when including the resource (copying only the children)" ]
      ]
      attribute contentonly {xsd:boolean }?

   db.module.renderas.attribute =
      [
         db:refpurpose [ "Changes the name of the root element of the included resource to the specified name" ]
      ]
      attribute renderas { xsd:QName }

   db.module.attlist =
      db.module.role.attribute?
    & db.module.chunk.attribute?
    & db.module.resourceref.attribute?
    & db.module.omittitles.attribute?
    & db.module.contentonly.attribute?
    & db.module.renderas.attribute?
    & db.common.attributes

   db.module.info = db.info?

   db.module =
      [
         s:pattern [
            s:title [ "Specification of renderas" ]
            s:rule [
               context = "db:module"
               s:assert [
                  test = "not(@renderas and db:output/@renderas)"
                  "The renderas attribute can be specified on either the structure or output, but not both."
               ]
            ]
         ]
      ]
      element module {
         db.module.attlist,
         ((db.output | db.filterin | db.filterout)*,
            db.module.info,
            db.merge?,
            db.module*)
      }
}

# ======================================================================

[
   db:refname [ "filterout" ]
   db:refmiscinfo [ class = "manual" "assembly" ]
   db:refpurpose [ "Elements with effectivity attributes matching this element are suppressed" ]
]
div {
   db.filterout.role.attribute = attribute role { text }

   db.filterout.attlist =
      db.filterout.role.attribute?
    & db.common.attributes

   db.filterout =
      element filterout {
         db.filterout.attlist,
         empty
      }
}

# ======================================================================

[
   db:refname [ "filterin" ]
   db:refmiscinfo [ class = "manual" "assembly" ]
   db:refpurpose [ "Elements with effectivity attributes matching this element are allowed" ]
]
div {
   db.filterin.role.attribute = attribute role { text }

   db.filterin.attlist =
      db.filterin.role.attribute?
    & db.common.attributes

   db.filterin =
      element filterin {
         db.filterin.attlist,
         empty
      }
}

# ======================================================================

[
   db:refname [ "relationships" ]
   db:refmiscinfo [ class = "manual" "assembly" ]
   db:refpurpose [ "Groups relationship elements to define associations between resources" ]
]
div {
   db.relationships.role.attribute = attribute role { text }

   db.relationships.type.attribute =
      [
         db:refpurpose [ "Identifies the type of the contained relationships" ]
      ]
      attribute type { xsd:NMTOKENS }

   db.relationships.attlist =
      db.relationships.role.attribute?
    & db.relationships.type.attribute?
    & db.relationships.instance.attribute?
    & db.common.attributes

   db.relationships.info = db._info

   db.relationships =
      element relationships {
         db.relationships.attlist,
         db.relationships.info,
         (db.relationship|db.instance)+
      }
}

# ======================================================================

[
   db:refname [ "relationship" ]
   db:refmiscinfo [ class = "manual" "assembly" ]
   db:refpurpose [ "A relationship associates one or more resources" ]
]
div {
   db.relationship.role.attribute = attribute role { text }

   db.relationship.type.attribute =
      [
         db:refpurpose [ "Identifies the type of the relationship" ]
      ]
      attribute type { xsd:NMTOKEN }

   db.relationship.attlist =
      db.relationship.role.attribute?
    & db.relationship.type.attribute?
    & db.linkend.attribute?
    & db.common.attributes

   db.relationship =
      element relationship {
         db.relationship.attlist,
         db.association,
         db.instance+
      }
}

# ======================================================================

[
   db:refname [ "association" ]
   db:refmiscinfo [ class = "manual" "assembly" ]
   db:refpurpose [ "Identifies the type of relationship between one or more resources" ]
]
div {
   db.association.role.attribute = attribute role { text }

   db.association.attlist =
      db.association.role.attribute?
    & db.linkend.attribute?
    & db.common.attributes

   db.association =
      element association {
         db.association.attlist,
         text?
      }
}

# ======================================================================

[
   db:refname [ "instance" ]
   db:refmiscinfo [ class = "manual" "assembly" ]
   db:refpurpose [ "Identifies a resource that is part of a relationship" ]
]
div {
   db.instance.role.attribute = attribute role { text }

   db.instance.linking.attribute =
      [
         db:refpurpose [ "Specifies the type of link for this instance" ]
      ]
      attribute linking { xsd:NMTOKENS }

   db.instance.attlist =
      db.instance.role.attribute?
    & db.instance.linking.attribute?
    & db.common.attributes

   db.instance =
      element instance {
         db.instance.attlist,
         db.linkend.attribute,
         empty
      }
}

# ======================================================================

[
   db:refname [ "transforms" ]
   db:refmiscinfo [ class = "manual" "assembly" ]
   db:refpurpose [ "List of transforms for converting from non-DocBook schemas" ]
]
div {
   db.transforms.role.attribute = attribute role { text }

   db.transforms.attlist =
      db.transforms.role.attribute?
    & db.common.attributes

   db.transforms.info = db._info

   db.transforms =
      element transforms {
         db.transforms.attlist,
         db.transforms.info,
         db.transform+
      }
}

# ======================================================================

[
   db:refname [ "transform" ]
   db:refmiscinfo [ class = "manual" "assembly" ]
   db:refpurpose [ "Identifies a transform for converting from a non-DocBook schema" ]
]
div {

   db.transform.role.attribute = attribute role { text }

   db.transform.grammar.attribute = db.grammar.attribute

   db.transform.href.attribute =
      [
         db:refpurpose [ "Indentifies the location of the data by URI" ]
      ]
      attribute href { xsd:anyURI }

   db.transform.name.attribute =
      [
         db:refpurpose [ "The name of the transform" ]
      ]
      attribute name { xsd:NMTOKEN }

   db.transform.attlist =
      db.transform.role.attribute?
    & (db.transform.grammar.attribute | db.transform.name.attribute)
    & db.transform.href.attribute
    & db.common.attributes

   db.transform =
      element transform {
         db.transform.attlist,
         empty
      }
}

# ======================================================================

[
   db:refname [ "description" ]
   db:refmiscinfo [ class = "manual" "assembly" ]
   db:refpurpose [ "A description of a resource or resources" ]
]
div {

   db.description.role.attribute = attribute role { text }

   db.description.attlist =
      db.description.role.attribute?
    & db.common.attributes

   db.description =
      element description {
         db.description.attlist,
         db._text
      }
}

